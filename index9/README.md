- 小知识
   - @即代替src文件夹
   - import...from...  (ES6的语法)
     - 中的from命令后面可以跟很多路径格式，若只给出vue，axios这样的包名，则会自动到node_modules中加载；若给出相对路径记文件前缀，则到指定位置寻找
     - 可以加载各种各样的文件：.js .vue .less等
     - 可以省略掉from直接引入




- 嵌套路由

- 如果你一个页面下面有另一个路由 当你去点击子路由的时候 你想让这个父路由也有样式的存在 就让它这个路径跟着你这个父路径下来的 
- vertical-align和text-align的区别  line-height
- scoped
- 动态路由
- 重定向
- replace和push的区别 根据项目来使用
- router-view的复用 使用多个router-view的时候可以配置一下我们的路由信息
  

- 子路由路径简写   路由重定向 路由别名
- 点击社区的时候会给你一个提示 提示你是否需要登录 点击的话留在home这个页面 确定的话进入到个人中心这一页 点击登录这个按钮之后代表我登录了 如何切换页面 再次点击社区可以直接进入了 从学术讨论去到课程学习会问你是否离开  需要用到这个"导航守卫"知识
- 1. 全局守卫 只要你写了全局守卫 无论你去了哪个路由下面 它就会去看看 全局是这个router实例的方法 首先要router上的方法才能进行一个守卫
- 2. 路由独享守卫  和全局守卫是一样的用法 只不过仅仅是守卫我们这个路径而已
- 首页必须是用户登录之后才能看到的信息 我们不用路由独享守卫了 因为路由独享守卫只看住了这个门 我们要让每个拥有组件的都拥有这个门
- 3. 组件内守卫
- 路由源信息
- 退出就显示登陆
- 正常是不会通过源信息去存储你登陆的状态 用源信息做这个功能是为了熟悉meta怎么用 我们可以自定义属性 相当于我们自定义存储的东西放到这个里面了 我们可以通过路径去寻找了 不能是兄弟路径寻找源信息 只能父子中的子找父的源信息  所以不适用路由复用了 注释一下
- 我们现在适用Vue-cli去搭的一个项目 它是不是所有的东西都压缩在一个js文件里面了 放在app.js这个文件里面了 现在我们这个项目比较小 假如无论这有很多信息
每次都要去加载app.js 无论我们去哪里 假如我们去课程学习 它也会把其他模块加载过来 我们想实现的功能是看什么就加载什么 按需加载 首屏加载越快越好
- 路由懒加载  304是从缓存当中读取文件了 不是说点击哪个就加载哪个吗 为什么有很多js文件出来 这个0.js是什么 在webpack当中如果把多个js打包成一个js的话
  会吧每个模块都起个名字 名字从0开始往下排 我们现在每个组件都有一个js文件 rel="prefetch"是预加载的意思 预加载就是利用浏览器空闲时间去下载用户将要需要的一些内容 也就是他在我们不经意之间统统把那些东西都预加载回来了 如何放到缓存里面 我们再去请求的话 我们再去请求1.js的时候 他要从缓存里面给我们拿了
  from disk cache是从缓存当中拿的 这样对我们的性能很好  预加载每次加载的时候就是从缓存当中来拿



(文章) 
- vue生命周期函数
- 网络状态码