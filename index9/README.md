### 用到的知识
- 嵌套路由
   - 如果你一个页面下面有另一个路由，当你去点击子路由的时候，你想让这个父路由也有样式的存在，就让它这个路径跟着你这个父路径下来的 
   -  `mode: 'history'`
      - 去掉# 让我们的URL更加美观
      - 也利于seo     
      - 如果单单是设置的了这个，当页面刷新或者收到添加路径的时候就会报404错误
   - 在style标签内添加scoped属性
      - 样式模块化(私有化)，不会对全局造成污染
      - 如果引用了第三方组件，需要在当前组件中局部修改第三方组件的样式，使用选择器>>>
      - scoped的实现原理: Vue中的scoped属性的效果主要通过PostCSS转义实现，例如转义之前的Vue代码 
         ```objc
         <template>
               <div>Vue.js scoped</div>
         </template>
         <style scoped>
            .scoped {
               font-size: 14px;
            }
         </style>
         ```
         浏览器渲染之后的代码：
         ```objc
         <div data-v-fed36922>Vue.js scoped</div>
         .scoped[data-v-fed36922] {
            font-size: 14px;
         }
         ```
         即: PostCSS给所有的dom添加了一个唯一不重复的动态属性，然后给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式私有化。
      - Vue中style属性为scoped如何穿透？
        ```objc
        <style scoped>
            外层选择器 >>> 第三方组件选择器 {

            }
        </style>
        ```     


- 动态路由
  - 使用场景：比如写商品详情页的时候，页面结构都一样，知识商品id的不同，所以这个时候就可以用动态路由
  - path: '*': 代表除了配置之外的一切路径
  - 重定向: redirect
      - 直接路径方式: 
        ```objc
        redirect: '/b'
        ```
      - 路径命名方式: 
        ```objc
        redirect: {name: 'foo'}
        ```
      - 函数方式: 
        ```objc
        redirect: to => {
           if(to.path === '/') {
              return '/home';
           }else {
              return {name: 'err};
           }
        }
        ```
  - 跳转页面
      - this.$router.push：把新条目推送到历史堆栈中，因此当用户单击浏览器后退按钮后，它们将被带到先前的URL, 相对于`<router -link :to="" >`。相对于原生的`window.history.pushState`
      - this.$router.replace: 它和router.push的区别是它导航时没有按下新的历史记录条目，顾名思义，它取代当前的条目。相对于原生的`window.history.replaceState`
      - this.$router.go：此方法采用单个整数作为参数，指示在历史堆栈中前进或后退的步数。相对于`window.history.go(n)`

  
- router-view的复用 使用多个router-view的时候可以配置一下我们的路由信息
   ```objc
   components: {
      default: Learn,
      'academic': Academic
   }
   <router-view class="router-view" name="academic"> (name就是我们配置的component的名字)
   ```
  - 子路由路径简写，不涉及到斜杆就行了，因为斜杆'/'表示的是路径默认第一路径加载的路由路径。   
  - 路由重定向 
  - 路由别名: alias
  

- 导航守卫
  - 主要用来判断跳转或取消的方式守卫导航，例如判断登录信息：没登录全部跳到登录页，判断必要操作是否进行，没进行的话中断跳转。   
  - 实现功能: 点击社区的时候会给你一个提示，提示你是否需要登录，没点击的话留在home这个页面，确定的话进入到个人中心这一页，点击登录这个按钮之后代表我登录了, 然后切换页面，再次点击社区可以直接进入了，从学术讨论去到课程学习会问你是否离开，需要用到这个"导航守卫"知识。
  - 实现方式  
    - 全局守卫：只要你写了全局守卫，无论你去了哪个路由下面，它就会去看看，全局是这个router实例的方法，首先要router上的方法才能进行一个守。`beforeEach beforeResolve afterEach`
    - 路由独享守卫：和全局守卫是一样的用法,只不过仅仅是守卫我们这个路径而已。首页必须是用户登录之后才能看到的信息，我们不用路由独享守卫了，因为路由独享守卫只看住了这个门，我们要让每个拥有组件的都拥有这个门。
    - 组件内守卫 
      ```objc 
      beforeRouterEnter // 在渲染该组件的对应路由之前被confirm前调用 不能获取组件实例this 因为当守卫执行前 组件实例还没被创建 虽然无法直接获取组件实例 但是我们可以通过next参数回调函数获取到当前实例进行操作  
      beforeRouterUpdate // 在当前路由改变，但是该组件被复用时调用。举例来说，对于一个带有动态参数的路径 /foo/:id，在/foo/1和/foo/2之间跳转的时候，由于会渲染同样的Foo组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。可以访问组件实例`this` 
      beforeRouterLeave // 导航离开该组件的对应路由时调用，可以访问组件实例`this`
      ```
   - 路由元信息(meta) 
      - 使用场景：做登录校验
      - meta这个值可以在自己对应的路径下取到，也可以在组件对应的路径下取到
      - 退出就显示登陆
      - 正常是不会通过元信息去存储你登陆的状态，用元信息做这个功能是为了熟悉meta怎么用，我们可以自定义属性，相当于我们自定义存储的东西放到这个里面了，我们可以通过路径去寻找了，不能是兄弟路径寻找源信息，只能父子中的子找父的源信息，所以不适用路由复用了，注释一下。 


- 路由懒加载      
   - 我们现在适用Vue-cli去搭的一个项目，它是不是所有的东西都压缩在一个js文件里面了，放在app.js这个文件里面了，现在我们这个项目比较小，假如无论这有很多信息。每次都要去加载app.js，无论我们去哪里，假如我们去课程学习，它也会把其他模块加载过来，我们想实现的功能是看什么就加载什么，按需加载，首屏加载越快越好。
   - 懒加载是结合vue的异步组件功能和webpack的代码分割功能，懒得加载路由组件非常容易。
   - 304：是从缓存当中读取文件了。不是说点击哪个就加载哪个吗？为什么有很多js文件出来，这个0.js是什么，在webpack当中如果把多个js打包成一个js的话。会把每个模块都起个名字，名字从0开始往下排，我们现在每个组件都有一个js文件 rel="prefetch"是预加载的意思，预加载就是利用浏览器空闲时间去下载用户将要需要的一些内容，也就是他在我们不经意之间统统把那些东西都预加载回来了，然后放到缓存里面，我们再去请求的话，我们再去请求1.js的时候，他要从缓存里面给我们拿了。
   - from disk cache是从缓存当中拿的，这样对我们的性能很好 ，预加载每次加载的时候就是从缓存当中来拿。









(文章) 
- vue生命周期函数
- 网络状态码
- vertical-align和text-align的区别  line-height